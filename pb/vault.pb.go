// Code generated by protoc-gen-go.
// source: vault.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	vault.proto

It has these top-level messages:
	InitStatusRequest
	InitStatusResponse
	InitRequest
	InitResponse
	SealStatusRequest
	SealStatusResponse
	UnsealRequest
	UnsealResponse
	Status
	SealStatus
	ConfigureRequest
	ConfigureResponse
	ConfigStatus
	MountOutput
	MountConfigOutput
	AuthMountOutput
	AuthConfigOutput
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The request message is currently empty, as this request is empty on Vault.
type InitStatusRequest struct {
}

func (m *InitStatusRequest) Reset()                    { *m = InitStatusRequest{} }
func (m *InitStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*InitStatusRequest) ProtoMessage()               {}
func (*InitStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// InitStatusResponse is the output from a GET to /sys/init
type InitStatusResponse struct {
	Status *Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Err    string  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
}

func (m *InitStatusResponse) Reset()                    { *m = InitStatusResponse{} }
func (m *InitStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*InitStatusResponse) ProtoMessage()               {}
func (*InitStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *InitStatusResponse) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type InitRequest struct {
	SecretShares          uint32   `protobuf:"varint,1,opt,name=secret_shares,json=secretShares" json:"secret_shares,omitempty"`
	SecretThreshold       uint32   `protobuf:"varint,2,opt,name=secret_threshold,json=secretThreshold" json:"secret_threshold,omitempty"`
	StoredShares          uint32   `protobuf:"varint,3,opt,name=stored_shares,json=storedShares" json:"stored_shares,omitempty"`
	PgpKeys               []string `protobuf:"bytes,4,rep,name=pgp_keys,json=pgpKeys" json:"pgp_keys,omitempty"`
	RecoveryShares        uint32   `protobuf:"varint,5,opt,name=recovery_shares,json=recoveryShares" json:"recovery_shares,omitempty"`
	RecoveryThreshold     uint32   `protobuf:"varint,6,opt,name=recovery_threshold,json=recoveryThreshold" json:"recovery_threshold,omitempty"`
	RecoveryPgpKeys       []string `protobuf:"bytes,7,rep,name=recovery_pgp_keys,json=recoveryPgpKeys" json:"recovery_pgp_keys,omitempty"`
	RootTokenPgpKey       string   `protobuf:"bytes,8,opt,name=root_token_pgp_key,json=rootTokenPgpKey" json:"root_token_pgp_key,omitempty"`
	RootTokenHolderEmail  string   `protobuf:"bytes,9,opt,name=root_token_holder_email,json=rootTokenHolderEmail" json:"root_token_holder_email,omitempty"`
	SecretKeyHolderEmails []string `protobuf:"bytes,10,rep,name=secret_key_holder_emails,json=secretKeyHolderEmails" json:"secret_key_holder_emails,omitempty"`
}

func (m *InitRequest) Reset()                    { *m = InitRequest{} }
func (m *InitRequest) String() string            { return proto.CompactTextString(m) }
func (*InitRequest) ProtoMessage()               {}
func (*InitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type InitResponse struct {
	Keys               []string `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	KeysBase64         []string `protobuf:"bytes,2,rep,name=keys_base64,json=keysBase64" json:"keys_base64,omitempty"`
	RecoveryKeys       []string `protobuf:"bytes,3,rep,name=recovery_keys,json=recoveryKeys" json:"recovery_keys,omitempty"`
	RecoveryKeysBase64 []string `protobuf:"bytes,4,rep,name=recovery_keys_base64,json=recoveryKeysBase64" json:"recovery_keys_base64,omitempty"`
	RootToken          string   `protobuf:"bytes,5,opt,name=root_token,json=rootToken" json:"root_token,omitempty"`
	Err                string   `protobuf:"bytes,6,opt,name=err" json:"err,omitempty"`
}

func (m *InitResponse) Reset()                    { *m = InitResponse{} }
func (m *InitResponse) String() string            { return proto.CompactTextString(m) }
func (*InitResponse) ProtoMessage()               {}
func (*InitResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// The request message is currently empty, as this request is empty on Vault.
type SealStatusRequest struct {
}

func (m *SealStatusRequest) Reset()                    { *m = SealStatusRequest{} }
func (m *SealStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*SealStatusRequest) ProtoMessage()               {}
func (*SealStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type SealStatusResponse struct {
	SealStatus *SealStatus `protobuf:"bytes,1,opt,name=seal_status,json=sealStatus" json:"seal_status,omitempty"`
	Err        string      `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
}

func (m *SealStatusResponse) Reset()                    { *m = SealStatusResponse{} }
func (m *SealStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*SealStatusResponse) ProtoMessage()               {}
func (*SealStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SealStatusResponse) GetSealStatus() *SealStatus {
	if m != nil {
		return m.SealStatus
	}
	return nil
}

type UnsealRequest struct {
	Key    string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Reset_ bool   `protobuf:"varint,2,opt,name=reset" json:"reset,omitempty"`
}

func (m *UnsealRequest) Reset()                    { *m = UnsealRequest{} }
func (m *UnsealRequest) String() string            { return proto.CompactTextString(m) }
func (*UnsealRequest) ProtoMessage()               {}
func (*UnsealRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type UnsealResponse struct {
	SealStatus *SealStatus `protobuf:"bytes,1,opt,name=seal_status,json=sealStatus" json:"seal_status,omitempty"`
	Err        string      `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
}

func (m *UnsealResponse) Reset()                    { *m = UnsealResponse{} }
func (m *UnsealResponse) String() string            { return proto.CompactTextString(m) }
func (*UnsealResponse) ProtoMessage()               {}
func (*UnsealResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UnsealResponse) GetSealStatus() *SealStatus {
	if m != nil {
		return m.SealStatus
	}
	return nil
}

//       Iniitialization status of Vault
type Status struct {
	Initialized bool `protobuf:"varint,1,opt,name=initialized" json:"initialized,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

//       Seal status of Vault
type SealStatus struct {
	Sealed      bool   `protobuf:"varint,1,opt,name=sealed" json:"sealed,omitempty"`
	T           uint32 `protobuf:"varint,2,opt,name=t" json:"t,omitempty"`
	N           uint32 `protobuf:"varint,3,opt,name=n" json:"n,omitempty"`
	Progress    uint32 `protobuf:"varint,4,opt,name=progress" json:"progress,omitempty"`
	Version     string `protobuf:"bytes,5,opt,name=version" json:"version,omitempty"`
	ClusterName string `protobuf:"bytes,6,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	ClusterId   string `protobuf:"bytes,7,opt,name=cluster_id,json=clusterId" json:"cluster_id,omitempty"`
}

func (m *SealStatus) Reset()                    { *m = SealStatus{} }
func (m *SealStatus) String() string            { return proto.CompactTextString(m) }
func (*SealStatus) ProtoMessage()               {}
func (*SealStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type ConfigureRequest struct {
	Url   string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	Token string `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
}

func (m *ConfigureRequest) Reset()                    { *m = ConfigureRequest{} }
func (m *ConfigureRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfigureRequest) ProtoMessage()               {}
func (*ConfigureRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type ConfigureResponse struct {
	ConfigStatus *ConfigStatus `protobuf:"bytes,1,opt,name=config_status,json=configStatus" json:"config_status,omitempty"`
	Err          string        `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
}

func (m *ConfigureResponse) Reset()                    { *m = ConfigureResponse{} }
func (m *ConfigureResponse) String() string            { return proto.CompactTextString(m) }
func (*ConfigureResponse) ProtoMessage()               {}
func (*ConfigureResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ConfigureResponse) GetConfigStatus() *ConfigStatus {
	if m != nil {
		return m.ConfigStatus
	}
	return nil
}

type ConfigStatus struct {
	ConfigId string                      `protobuf:"bytes,1,opt,name=config_id,json=configId" json:"config_id,omitempty"`
	Mounts   map[string]*MountOutput     `protobuf:"bytes,2,rep,name=mounts" json:"mounts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Auths    map[string]*AuthMountOutput `protobuf:"bytes,3,rep,name=auths" json:"auths,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Policies []string                    `protobuf:"bytes,4,rep,name=policies" json:"policies,omitempty"`
}

func (m *ConfigStatus) Reset()                    { *m = ConfigStatus{} }
func (m *ConfigStatus) String() string            { return proto.CompactTextString(m) }
func (*ConfigStatus) ProtoMessage()               {}
func (*ConfigStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ConfigStatus) GetMounts() map[string]*MountOutput {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *ConfigStatus) GetAuths() map[string]*AuthMountOutput {
	if m != nil {
		return m.Auths
	}
	return nil
}

type MountOutput struct {
	Type        string             `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Description string             `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	Config      *MountConfigOutput `protobuf:"bytes,3,opt,name=config" json:"config,omitempty"`
}

func (m *MountOutput) Reset()                    { *m = MountOutput{} }
func (m *MountOutput) String() string            { return proto.CompactTextString(m) }
func (*MountOutput) ProtoMessage()               {}
func (*MountOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *MountOutput) GetConfig() *MountConfigOutput {
	if m != nil {
		return m.Config
	}
	return nil
}

type MountConfigOutput struct {
	DefaultLeaseTtl uint32 `protobuf:"varint,1,opt,name=default_lease_ttl,json=defaultLeaseTtl" json:"default_lease_ttl,omitempty"`
	MaxLeaseTtl     uint32 `protobuf:"varint,2,opt,name=max_lease_ttl,json=maxLeaseTtl" json:"max_lease_ttl,omitempty"`
}

func (m *MountConfigOutput) Reset()                    { *m = MountConfigOutput{} }
func (m *MountConfigOutput) String() string            { return proto.CompactTextString(m) }
func (*MountConfigOutput) ProtoMessage()               {}
func (*MountConfigOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type AuthMountOutput struct {
	Type        string            `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Description string            `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	Config      *AuthConfigOutput `protobuf:"bytes,3,opt,name=config" json:"config,omitempty"`
}

func (m *AuthMountOutput) Reset()                    { *m = AuthMountOutput{} }
func (m *AuthMountOutput) String() string            { return proto.CompactTextString(m) }
func (*AuthMountOutput) ProtoMessage()               {}
func (*AuthMountOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *AuthMountOutput) GetConfig() *AuthConfigOutput {
	if m != nil {
		return m.Config
	}
	return nil
}

type AuthConfigOutput struct {
	DefaultLeaseTtl uint32 `protobuf:"varint,1,opt,name=default_lease_ttl,json=defaultLeaseTtl" json:"default_lease_ttl,omitempty"`
	MaxLeaseTtl     uint32 `protobuf:"varint,2,opt,name=max_lease_ttl,json=maxLeaseTtl" json:"max_lease_ttl,omitempty"`
}

func (m *AuthConfigOutput) Reset()                    { *m = AuthConfigOutput{} }
func (m *AuthConfigOutput) String() string            { return proto.CompactTextString(m) }
func (*AuthConfigOutput) ProtoMessage()               {}
func (*AuthConfigOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func init() {
	proto.RegisterType((*InitStatusRequest)(nil), "pb.InitStatusRequest")
	proto.RegisterType((*InitStatusResponse)(nil), "pb.InitStatusResponse")
	proto.RegisterType((*InitRequest)(nil), "pb.InitRequest")
	proto.RegisterType((*InitResponse)(nil), "pb.InitResponse")
	proto.RegisterType((*SealStatusRequest)(nil), "pb.SealStatusRequest")
	proto.RegisterType((*SealStatusResponse)(nil), "pb.SealStatusResponse")
	proto.RegisterType((*UnsealRequest)(nil), "pb.UnsealRequest")
	proto.RegisterType((*UnsealResponse)(nil), "pb.UnsealResponse")
	proto.RegisterType((*Status)(nil), "pb.Status")
	proto.RegisterType((*SealStatus)(nil), "pb.SealStatus")
	proto.RegisterType((*ConfigureRequest)(nil), "pb.ConfigureRequest")
	proto.RegisterType((*ConfigureResponse)(nil), "pb.ConfigureResponse")
	proto.RegisterType((*ConfigStatus)(nil), "pb.ConfigStatus")
	proto.RegisterType((*MountOutput)(nil), "pb.MountOutput")
	proto.RegisterType((*MountConfigOutput)(nil), "pb.MountConfigOutput")
	proto.RegisterType((*AuthMountOutput)(nil), "pb.AuthMountOutput")
	proto.RegisterType((*AuthConfigOutput)(nil), "pb.AuthConfigOutput")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Vault service

type VaultClient interface {
	// InitStatus retrieves the output from a GET to /sys/init
	// This returns the initialization status of Vault.
	InitStatus(ctx context.Context, in *InitStatusRequest, opts ...grpc.CallOption) (*InitStatusResponse, error)
	// Init retrieves the output from a PUT to /sys/init
	// This initializes a new Vault.  Vault must not have been previously initialized.
	Init(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error)
	// SealStatus retrieves the output from a GET to /sys/seal-status
	// Returns the seal status of the Vault.
	SealStatus(ctx context.Context, in *SealStatusRequest, opts ...grpc.CallOption) (*SealStatusResponse, error)
	// Unseal retrieves the output from a PUT to /sys/unseal
	// Enter a single master key share to progress the unsealing of the Vault.
	// If the threshold number of master key shares is reached, Vault will attempt to
	// unseal the Vault. Otherwise, this API must be called multiple times until that
	// threshold is met.
	Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error)
	// Configure applies a set of configuration files to Vault. By
	// convention, these are json files located at some URL (e.g. git or
	// aws s3).
	Configure(ctx context.Context, in *ConfigureRequest, opts ...grpc.CallOption) (*ConfigureResponse, error)
}

type vaultClient struct {
	cc *grpc.ClientConn
}

func NewVaultClient(cc *grpc.ClientConn) VaultClient {
	return &vaultClient{cc}
}

func (c *vaultClient) InitStatus(ctx context.Context, in *InitStatusRequest, opts ...grpc.CallOption) (*InitStatusResponse, error) {
	out := new(InitStatusResponse)
	err := grpc.Invoke(ctx, "/pb.Vault/InitStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultClient) Init(ctx context.Context, in *InitRequest, opts ...grpc.CallOption) (*InitResponse, error) {
	out := new(InitResponse)
	err := grpc.Invoke(ctx, "/pb.Vault/Init", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultClient) SealStatus(ctx context.Context, in *SealStatusRequest, opts ...grpc.CallOption) (*SealStatusResponse, error) {
	out := new(SealStatusResponse)
	err := grpc.Invoke(ctx, "/pb.Vault/SealStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultClient) Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error) {
	out := new(UnsealResponse)
	err := grpc.Invoke(ctx, "/pb.Vault/Unseal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vaultClient) Configure(ctx context.Context, in *ConfigureRequest, opts ...grpc.CallOption) (*ConfigureResponse, error) {
	out := new(ConfigureResponse)
	err := grpc.Invoke(ctx, "/pb.Vault/Configure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Vault service

type VaultServer interface {
	// InitStatus retrieves the output from a GET to /sys/init
	// This returns the initialization status of Vault.
	InitStatus(context.Context, *InitStatusRequest) (*InitStatusResponse, error)
	// Init retrieves the output from a PUT to /sys/init
	// This initializes a new Vault.  Vault must not have been previously initialized.
	Init(context.Context, *InitRequest) (*InitResponse, error)
	// SealStatus retrieves the output from a GET to /sys/seal-status
	// Returns the seal status of the Vault.
	SealStatus(context.Context, *SealStatusRequest) (*SealStatusResponse, error)
	// Unseal retrieves the output from a PUT to /sys/unseal
	// Enter a single master key share to progress the unsealing of the Vault.
	// If the threshold number of master key shares is reached, Vault will attempt to
	// unseal the Vault. Otherwise, this API must be called multiple times until that
	// threshold is met.
	Unseal(context.Context, *UnsealRequest) (*UnsealResponse, error)
	// Configure applies a set of configuration files to Vault. By
	// convention, these are json files located at some URL (e.g. git or
	// aws s3).
	Configure(context.Context, *ConfigureRequest) (*ConfigureResponse, error)
}

func RegisterVaultServer(s *grpc.Server, srv VaultServer) {
	s.RegisterService(&_Vault_serviceDesc, srv)
}

func _Vault_InitStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServer).InitStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Vault/InitStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServer).InitStatus(ctx, req.(*InitStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vault_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Vault/Init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServer).Init(ctx, req.(*InitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vault_SealStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SealStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServer).SealStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Vault/SealStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServer).SealStatus(ctx, req.(*SealStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vault_Unseal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServer).Unseal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Vault/Unseal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServer).Unseal(ctx, req.(*UnsealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vault_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VaultServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Vault/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VaultServer).Configure(ctx, req.(*ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Vault_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Vault",
	HandlerType: (*VaultServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitStatus",
			Handler:    _Vault_InitStatus_Handler,
		},
		{
			MethodName: "Init",
			Handler:    _Vault_Init_Handler,
		},
		{
			MethodName: "SealStatus",
			Handler:    _Vault_SealStatus_Handler,
		},
		{
			MethodName: "Unseal",
			Handler:    _Vault_Unseal_Handler,
		},
		{
			MethodName: "Configure",
			Handler:    _Vault_Configure_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("vault.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 976 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0x51, 0x73, 0xdb, 0x44,
	0x10, 0xae, 0xec, 0xd8, 0xb1, 0x57, 0x76, 0x6c, 0x5f, 0x9c, 0x22, 0x5c, 0x18, 0x82, 0x18, 0x86,
	0xb4, 0xa5, 0x81, 0x9a, 0x96, 0x32, 0x99, 0xe9, 0x03, 0x30, 0x9d, 0x21, 0x2d, 0x05, 0x46, 0x09,
	0xf0, 0xc2, 0x8c, 0x46, 0xb6, 0xb7, 0x89, 0x26, 0xb2, 0x24, 0xee, 0x4e, 0x99, 0x9a, 0x7f, 0xc3,
	0xbf, 0xe0, 0x89, 0x3f, 0xd0, 0x3f, 0xc5, 0xdc, 0xde, 0x9d, 0x24, 0x3b, 0x7e, 0x62, 0xf2, 0xe4,
	0xbb, 0x6f, 0xbf, 0xfd, 0xf6, 0x6e, 0x77, 0x6f, 0x2d, 0x70, 0xaf, 0xa3, 0x22, 0x91, 0xc7, 0x39,
	0xcf, 0x64, 0xc6, 0x1a, 0xf9, 0xcc, 0xdf, 0x87, 0xd1, 0x69, 0x1a, 0xcb, 0x33, 0x19, 0xc9, 0x42,
	0x04, 0xf8, 0x67, 0x81, 0x42, 0xfa, 0x2f, 0x81, 0xd5, 0x41, 0x91, 0x67, 0xa9, 0x40, 0xe6, 0x43,
	0x5b, 0x10, 0xe2, 0x39, 0x87, 0xce, 0x91, 0x3b, 0x85, 0xe3, 0x7c, 0x76, 0x6c, 0x38, 0xc6, 0xc2,
	0x86, 0xd0, 0x44, 0xce, 0xbd, 0xc6, 0xa1, 0x73, 0xd4, 0x0d, 0xd4, 0xd2, 0xff, 0xb7, 0x09, 0xae,
	0x12, 0x33, 0xda, 0xec, 0x13, 0xe8, 0x0b, 0x9c, 0x73, 0x94, 0xa1, 0xb8, 0x8c, 0x38, 0x6a, 0xb1,
	0x7e, 0xd0, 0xd3, 0xe0, 0x19, 0x61, 0xec, 0x3e, 0x0c, 0x0d, 0x49, 0x5e, 0x72, 0x14, 0x97, 0x59,
	0xb2, 0x20, 0xcd, 0x7e, 0x30, 0xd0, 0xf8, 0xb9, 0x85, 0x49, 0x4f, 0x66, 0x1c, 0x17, 0x56, 0xaf,
	0x69, 0xf4, 0x08, 0x34, 0x7a, 0xef, 0x43, 0x27, 0xbf, 0xc8, 0xc3, 0x2b, 0x5c, 0x09, 0x6f, 0xe7,
	0xb0, 0x79, 0xd4, 0x0d, 0x76, 0xf3, 0x8b, 0xfc, 0x15, 0xae, 0x04, 0xfb, 0x0c, 0x06, 0x1c, 0xe7,
	0xd9, 0x35, 0xf2, 0x95, 0x55, 0x68, 0x91, 0xc2, 0x9e, 0x85, 0x8d, 0xc6, 0x23, 0x60, 0x25, 0xb1,
	0x3a, 0x55, 0x9b, 0xb8, 0x23, 0x6b, 0xa9, 0xce, 0xf5, 0x00, 0x4a, 0x30, 0x2c, 0x63, 0xef, 0x52,
	0xec, 0x32, 0xe0, 0x2f, 0xe6, 0x0c, 0x0f, 0x81, 0xf1, 0x2c, 0x93, 0xa1, 0xcc, 0xae, 0x30, 0xb5,
	0x6c, 0xaf, 0x43, 0x49, 0x1c, 0x28, 0xcb, 0xb9, 0x32, 0x68, 0x36, 0x7b, 0x0a, 0xef, 0xd5, 0xc8,
	0x2a, 0x16, 0xf2, 0x10, 0x97, 0x51, 0x9c, 0x78, 0x5d, 0xf2, 0x18, 0x97, 0x1e, 0x3f, 0x90, 0xf1,
	0x85, 0xb2, 0xb1, 0x67, 0xe0, 0x99, 0x94, 0x5e, 0xe1, 0x6a, 0xcd, 0x4d, 0x78, 0x40, 0xc7, 0x3a,
	0xd0, 0xf6, 0x57, 0xb8, 0xaa, 0xf9, 0x09, 0xff, 0x9d, 0x03, 0x3d, 0x5d, 0x40, 0xd3, 0x07, 0x0c,
	0x76, 0xe8, 0x32, 0x0e, 0x79, 0xd1, 0x9a, 0x7d, 0x04, 0xae, 0xfa, 0x0d, 0x67, 0x91, 0xc0, 0xaf,
	0x9f, 0x78, 0x0d, 0x32, 0x81, 0x82, 0xbe, 0x23, 0x44, 0x95, 0xa9, 0x4c, 0x07, 0x79, 0x37, 0x89,
	0xd2, 0xb3, 0x20, 0xe5, 0xe1, 0x4b, 0x18, 0xaf, 0x91, 0xac, 0x9c, 0x2e, 0x19, 0xab, 0x73, 0x8d,
	0xec, 0x87, 0x00, 0x55, 0x32, 0xa8, 0x70, 0xdd, 0xa0, 0x5b, 0xde, 0xdf, 0xb6, 0x63, 0xbb, 0x6a,
	0xc7, 0x7d, 0x18, 0x9d, 0x61, 0x94, 0xac, 0xf7, 0xfb, 0xef, 0xc0, 0xea, 0xa0, 0xb9, 0xe7, 0x17,
	0xe0, 0x0a, 0x8c, 0x92, 0x70, 0xad, 0xe9, 0xf7, 0xa8, 0xe9, 0x2b, 0x32, 0x88, 0x72, 0xbd, 0xa5,
	0xf9, 0x9f, 0x41, 0xff, 0xd7, 0x54, 0x31, 0x6c, 0xf7, 0x0f, 0xa1, 0xa9, 0x4a, 0xeb, 0x68, 0xca,
	0x15, 0xae, 0xd8, 0x18, 0x5a, 0x1c, 0x05, 0x4a, 0x72, 0xeb, 0x04, 0x7a, 0xe3, 0x9f, 0xc1, 0x9e,
	0x75, 0xbc, 0xbd, 0xd3, 0x3c, 0x80, 0xb6, 0xb1, 0x1d, 0x82, 0x1b, 0xa7, 0xb1, 0x8c, 0xa3, 0x24,
	0xfe, 0x0b, 0x17, 0x24, 0xd6, 0x09, 0xea, 0x90, 0xff, 0x8f, 0x03, 0x50, 0x09, 0xb3, 0xbb, 0xd0,
	0x56, 0xd2, 0x25, 0xd7, 0xec, 0x58, 0x0f, 0x1c, 0x69, 0x5e, 0xa6, 0x23, 0xd5, 0x2e, 0x35, 0xef,
	0xcf, 0x49, 0xd9, 0x04, 0x3a, 0x39, 0xcf, 0x2e, 0x38, 0x0a, 0xf5, 0xe8, 0x14, 0x58, 0xee, 0x99,
	0x07, 0xbb, 0xd7, 0xc8, 0x45, 0x9c, 0xd9, 0xa2, 0xd9, 0x2d, 0xfb, 0x18, 0x7a, 0xf3, 0xa4, 0x10,
	0x12, 0x79, 0x98, 0x46, 0x4b, 0x34, 0xb5, 0x73, 0x0d, 0xf6, 0x53, 0xb4, 0x44, 0x55, 0x74, 0x4b,
	0x89, 0x17, 0xde, 0xae, 0x2e, 0xba, 0x41, 0x4e, 0x17, 0xfe, 0x09, 0x0c, 0xbf, 0xcf, 0xd2, 0x37,
	0xf1, 0x45, 0xc1, 0xb1, 0x96, 0xf7, 0x82, 0x27, 0x36, 0xef, 0x05, 0x4f, 0x54, 0xde, 0x75, 0xd3,
	0xe8, 0x04, 0xe9, 0x8d, 0xff, 0x07, 0x8c, 0x6a, 0xbe, 0x26, 0xf5, 0x4f, 0xa1, 0x3f, 0x27, 0x70,
	0x3d, 0xf9, 0x43, 0x95, 0x7c, 0xcd, 0x36, 0xe9, 0xef, 0xcd, 0x6b, 0xbb, 0x2d, 0x05, 0x78, 0xd7,
	0x80, 0x5e, 0xdd, 0x81, 0xdd, 0x83, 0xae, 0x51, 0x8e, 0x17, 0xe6, 0x70, 0x1d, 0x0d, 0x9c, 0x2e,
	0xd8, 0x13, 0x68, 0x2f, 0xb3, 0x22, 0x95, 0x82, 0x9e, 0x93, 0x3b, 0xfd, 0x60, 0x33, 0xde, 0xf1,
	0x6b, 0x32, 0xbf, 0x48, 0x25, 0x5f, 0x05, 0x86, 0xcb, 0x1e, 0x43, 0x2b, 0x2a, 0xe4, 0xa5, 0x7e,
	0x60, 0xee, 0xf4, 0xde, 0x0d, 0xa7, 0x6f, 0x95, 0x55, 0xfb, 0x68, 0x26, 0x15, 0x2a, 0x4b, 0xe2,
	0x79, 0x8c, 0x76, 0x3a, 0x96, 0xfb, 0xc9, 0x4b, 0x70, 0x6b, 0x51, 0xb6, 0xf4, 0xef, 0xa7, 0xd0,
	0xba, 0x8e, 0x92, 0x02, 0xe9, 0x9e, 0xee, 0x74, 0xa0, 0xe2, 0x91, 0xc7, 0xcf, 0x85, 0xcc, 0x0b,
	0x19, 0x68, 0xeb, 0x49, 0xe3, 0x1b, 0x67, 0xf2, 0x1a, 0xa0, 0x0a, 0xbe, 0x45, 0xea, 0xfe, 0xba,
	0xd4, 0xbe, 0x92, 0x52, 0x0e, 0xdb, 0xe5, 0x7c, 0x6e, 0x8e, 0xa6, 0x2d, 0x6a, 0x2c, 0xc9, 0x55,
	0x8e, 0x46, 0x90, 0xd6, 0xaa, 0xcf, 0x17, 0x28, 0xe6, 0x3c, 0xce, 0xa5, 0x6a, 0x35, 0x5d, 0x8a,
	0x3a, 0xc4, 0x1e, 0x41, 0x5b, 0x27, 0x9c, 0xfa, 0xd6, 0x9d, 0x1e, 0x94, 0xe7, 0xd7, 0x49, 0x33,
	0x61, 0x0d, 0xc9, 0x9f, 0xc3, 0xe8, 0x86, 0x51, 0x8d, 0xfa, 0x05, 0xbe, 0x51, 0x7f, 0xac, 0x61,
	0x82, 0x91, 0xc0, 0x50, 0xca, 0xc4, 0xfc, 0xad, 0x0d, 0x8c, 0xe1, 0x47, 0x85, 0x9f, 0xcb, 0x84,
	0xf9, 0xd0, 0x5f, 0x46, 0x6f, 0x6b, 0x3c, 0xfd, 0x78, 0xdc, 0x65, 0xf4, 0xd6, 0x72, 0xfc, 0x02,
	0x06, 0x1b, 0xd7, 0xfe, 0x9f, 0x97, 0xfb, 0x7c, 0xe3, 0x72, 0x63, 0x9b, 0xd1, 0xad, 0x77, 0x9b,
	0xc1, 0x70, 0xd3, 0x76, 0xdb, 0x57, 0x9b, 0xfe, 0xdd, 0x80, 0xd6, 0x6f, 0xca, 0x8b, 0x3d, 0x07,
	0xa8, 0xbe, 0x31, 0x18, 0xa5, 0xfd, 0xc6, 0x87, 0xc8, 0xe4, 0xee, 0x26, 0xac, 0x5f, 0xa4, 0x7f,
	0x87, 0x3d, 0x84, 0x1d, 0x85, 0xb3, 0x81, 0x65, 0x58, 0x97, 0x61, 0x05, 0x94, 0xe4, 0xe7, 0x6b,
	0xb3, 0xec, 0x60, 0x63, 0x68, 0xd6, 0x63, 0xdd, 0xfc, 0x1b, 0xf0, 0xef, 0xb0, 0xc7, 0xd0, 0xd6,
	0xc3, 0x98, 0x8d, 0x14, 0x67, 0x6d, 0xa2, 0x4f, 0x58, 0x1d, 0x2a, 0x5d, 0x4e, 0xa0, 0x5b, 0xce,
	0x11, 0x36, 0xae, 0xde, 0x60, 0x35, 0x92, 0x26, 0x07, 0x1b, 0xa8, 0xf5, 0x9d, 0xb5, 0xe9, 0xeb,
	0xec, 0xab, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xb2, 0xa5, 0xed, 0x39, 0xac, 0x09, 0x00, 0x00,
}
